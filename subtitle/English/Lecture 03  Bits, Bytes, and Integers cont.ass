[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 03  Bits, Bytes, and Integers cont.mp4
Video File: ../../../../Desktop/csapp/Lecture 03  Bits, Bytes, and Integers cont.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.750000
Scroll Position: 780
Active Line: 794
Video Position: 137556

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Source Han Sans CN,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,2.2,1,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.04,English,,0,0,0,,I guess one thing I I and the rest of the staff request is that you
Dialogue: 0,0:00:05.72,0:00:08.90,English,,0,0,0,, Whenever you have a question you first read the book
Dialogue: 0,0:00:08.90,0:00:14.44,English,,0,0,0,,Then you reread the assignment and you maybe reread it again and then you ask us
Dialogue: 0,0:00:14.44,0:00:18.02,English,,0,0,0,,Because a lot of the questions we're getting are ones
Dialogue: 0,0:00:18.02,0:00:27.92,English,,0,0,0,,Where we just say look at this page of the book,look at this paragraph of the assignment, look at this part of the file that you were given
Dialogue: 0,0:00:28.40,0:00:35.70,English,,0,0,0,,And so I mean, there's a lot of stuff and I understand how sometimes it's easy to miss things 
Dialogue: 0,0:00:35.82,0:00:41.90,English,,0,0,0,,So not saying don't ever ask questions but just before you ask your questions try and figure out
Dialogue: 0,0:00:41.90,0:00:46.84,English,,0,0,0,,If I really should have come through the resources I have available to see
Dialogue: 0,0:00:46.84,0:00:49.62,English,,0,0,0,, If the answer to my question is can be found there
Dialogue: 0,0:00:50.38,0:00:54.54,English,,0,0,0,, So anyways enjoy the lab
Dialogue: 0,0:00:55.38,0:01:02.32,English,,0,0,0,,So today is a suit a second part of a two-part lecture on integers and integer arithmetic
Dialogue: 0,0:01:02.32,0:01:12.52,English,,0,0,0,, Last time we looked at representations about  how bit patterns can be interpreted is either of unsigned numbers meaning
Dialogue: 0,0:01:12.52,0:01:17.94,English,,0,0,0,, They range between 0 and 2^(w-1)
Dialogue: 0,0:01:18.62,0:01:26.16,English,,0,0,0,,Or as two's complement numbers which is the most compliment usual way to represent what are sometimes called signed numbers
Dialogue: 0,0:01:26.54,0:01:28.56,English,,0,0,0,,Ones it can be either negative or positive
Dialogue: 0,0:01:29.08,0:01:33.00,English,,0,0,0,,And by the way there are other ways to represent signed numbers out there but
Dialogue: 0,0:01:33.38,0:01:40.40,English,,0,0,0,,Two's complement is so overwhelmingly the most used system that that's what we concentrate on
Dialogue: 0,0:01:41.50,0:01:43.26,English,,0,0,0,,Today what we'll do is that 
Dialogue: 0,0:01:43.26,0:01:51.08,English,,0,0,0,,Now go beyond the representations of these values to talk about arithmetic operations on them and some of their properties
Dialogue: 0,0:01:52.50,0:01:56.12,English,,0,0,0,, And what we'll do in general is talk about the unsigned case
Dialogue: 0,0:01:56.12,0:01:59.90,English,,0,0,0,, Which is in some ways easier to understand and more intuitive
Dialogue: 0,0:02:00.16,0:02:02.24,English,,0,0,0,, And then talk about the two's complement case
Dialogue: 0,0:02:02.96,0:02:05.52,English,,0,0,0,, So the basic rule on this is
Dialogue: 0,0:02:05.88,0:02:14.40,English,,0,0,0,,If you take two numbers that range between up to the maximum value of an unsigned number value add them
Dialogue: 0,0:02:14.94,0:02:20.10,English,,0,0,0,,That in principle you might need to get an extra bit to represent that sum
Dialogue: 0,0:02:20.10,0:02:24.70,English,,0,0,0,,If you want to represent the true sum the sort of integer sum of those two numbers
Dialogue: 0,0:02:25.32,0:02:27.02,English,,0,0,0,,Because you've doubling it
Dialogue: 0,0:02:27.18,0:02:33.68,English,,0,0,0,,And unfortunately we can't just go out and add more bits to your computer indefinitely
Dialogue: 0,0:02:33.68,0:02:36.66,English,,0,0,0,,So we just stop it at some point and say
Dialogue: 0,0:02:37.04,0:02:42.38,English,,0,0,0,, Well whatever bit happened to be in that sort of next bit position
Dialogue: 0,0:02:42.38,0:02:45.04,English,,0,0,0,, We're just going to drop it and pretend it doesn't exist
Dialogue: 0,0:02:45.66,0:02:50.86,English,,0,0,0,, And say that the result of addition is just whatever the w bit pattern you get
Dialogue: 0,0:02:51.26,0:02:54.06,English,,0,0,0,,If you only consider the first w bits out of it
Dialogue: 0,0:02:54.80,0:03:00.64,English,,0,0,0,,With no warning no messages no error or anything 
Dialogue: 0,0:03:00.64,0:03:02.74,English,,0,0,0,,This is just it happens silently
Dialogue: 0,0:03:04.68,0:03:12.68,English,,0,0,0,, So for, two's complement this is not such a hard thing to understand
Dialogue: 0,0:03:12.88,0:03:18.40,English,,0,0,0,, It can be thought of as just modular arithmetic computing modulo the two to the word size
Dialogue: 0,0:03:18.88,0:03:23.04,English,,0,0,0,,I'm going to use some examples and this time I've got them worked out a little more carefully
Dialogue: 0,0:03:23.04,0:03:25.54,English,,0,0,0,,So I won't get mixed up as much
Dialogue: 0,0:03:25.90,0:03:28.74,English,,0,0,0,,And we'll use a word size of 4 here
Dialogue: 0,0:03:29.02,0:03:30.64,English,,0,0,0,,And as I mentioned last time 
Dialogue: 0,0:03:31.26,0:03:35.98,English,,0,0,0,,It really helps with this to work do the examples with small word sizes
Dialogue: 0,0:03:36.44,0:03:44.62,English,,0,0,0,,To get you intuition for it rather than trying to write out 32-bit numbers or 64-bit numbers is something like that
Dialogue: 0,0:03:45.16,0:03:47.42,English,,0,0,0,, So if you think about in the unsigned case
Dialogue: 0,0:03:52.24,0:04:03.32,English,,0,0,0,, A 4-bit number means that it will range between 0 and 2^(4-1) or 15 right
Dialogue: 0,0:04:04.00,0:04:09.44,English,,0,0,0,,So let's just do a few examples of cases where it overflows
Dialogue: 0,0:04:10.83,0:04:14.68,English,,0,0,0,, So if you add 13 to 5
Dialogue: 0,0:04:20.80,0:04:23.38,English,,0,0,0,,First of all you know I assume already that
Dialogue: 0,0:04:23.38,0:04:26.32,English,,0,0,0,,You just add binary numbers the way you learned in school
Dialogue: 0,0:04:26.80,0:04:31.38,English,,0,0,0,,Just doing carries and so forth except it's all modulo two
Dialogue: 0,0:04:31.38,0:04:41.74,English,,0,0,0,,So this is 0 carry 1 1, 0  carry 1,0 carry 1
Dialogue: 0,0:04:42.56,0:04:48.66,English,,0,0,0,,So in principle to represent the sum which is this is 5, so to represent 18
Dialogue: 0,0:04:49.46,0:04:51.56,English,,0,0,0,,You need 5 bits, not 4
Dialogue: 0,0:04:52.54,0:04:58.96,English,,0,0,0,,But we're just going to conveniently drop that number and say that this is actually a 2
Dialogue: 0,0:04:59.78,0:05:03.48,English,,0,0,0,,Which of course is what 18 modules of 16 is
Dialogue: 0,0:05:04.76,0:05:07.44,English,,0,0,0,,So the unsigned case is really pretty straightforward
Dialogue: 0,0:05:12.80,0:05:15.98,English,,0,0,0,,And we can visualize this in this pictures in the book too
Dialogue: 0,0:05:16.64,0:05:23.96,English,,0,0,0,, By seeing if you are representing on the x and y axis what they call U and V 
Dialogue: 0,0:05:25.88,0:05:29.92,English,,0,0,0,,Values between 0 and 15 the range of possible unsigned numbers
Dialogue: 0,0:05:30.24,0:05:34.68,English,,0,0,0,,And if we add those we could get a sum that's up to as much as 30
Dialogue: 0,0:05:35.88,0:05:39.52,English,,0,0,0,,Which would in principle require 5 bits to represent
Dialogue: 0,0:05:40.72,0:05:45.16,English,,0,0,0,, But what we'll do is we'll just by dropping that most significant bit
Dialogue: 0,0:05:45.16,0:05:47.00,English,,0,0,0,,What we do is sort of create a cliff
Dialogue: 0,0:05:47.52,0:05:53.84,English,,0,0,0,,That when you roll over from 15 to 16  instead it drops all the way down to 0
Dialogue: 0,0:05:54.34,0:05:56.58,English,,0,0,0,,And that's referred to as an overflow
Dialogue: 0,0:05:57.24,0:06:06.06,English,,0,0,0,, And then from there we'll build up to the maximum value here will be 14,which is 30-16
Dialogue: 0,0:06:06.28,0:06:10.24,English,,0,0,0,,So what we've done is basically as this picture shows when we overflow
Dialogue: 0,0:06:10.78,0:06:15.18,English,,0,0,0,,We effectively subtract off 2^w from the sum
Dialogue: 0,0:06:15.70,0:06:20.20,English,,0,0,0,, And keep it within the representable range of w bit numbers
Dialogue: 0,0:06:21.26,0:06:22.96,English,,0,0,0,, So that's an unsigned
Dialogue: 0,0:06:24.16,0:06:25.02,English,,0,0,0,,Two's complement
Dialogue: 0,0:06:25.74,0:06:34.92,English,,0,0,0,,The first thing I want to convince you of is it two's complement addition looks just like a regular edition
Dialogue: 0,0:06:36.02,0:06:39.94,English,,0,0,0,, In other words I can perform a subtraction 
Dialogue: 0,0:06:41.06,0:06:47.24,English,,0,0,0,,And addition of subtraction of numbers by using this two's complement representation for negative numbers  
Dialogue: 0,0:06:48.04,0:06:51.40,English,,0,0,0,,So well let me just show you some examples of that
Dialogue: 0,0:06:57.54,0:07:00.52,English,,0,0,0,,So first of all remember that what range of values
Dialogue: 0,0:07:00.52,0:07:03.80,English,,0,0,0,,What's the smallest number that could be representatively the 4 bit
Dialogue: 0,0:07:04.32,0:07:07.60,English,,0,0,0,,The most negative number 4 bit two's complement number
Dialogue: 0,0:07:09.10,0:07:10.10,English,,0,0,0,, -8
Dialogue: 0,0:07:12.18,0:07:15.88,English,,0,0,0,,And the largest plus 7 thank you
Dialogue: 0,0:07:18.70,0:07:21.96,English,,0,0,0,,So let's just do some examples if we took
Dialogue: 0,0:07:26.64,0:07:33.98,English,,0,0,0,,This number 1101, as a two's complement number is -3
Dialogue: 0,0:07:35.12,0:07:43.26,English,,0,0,0,,And we add it to 5. We'll get what we got before
Dialogue: 0,0:07:51.50,0:07:56.26,English,,0,0,0,,And we're not good at we're going to ignore whatever carry bit it is and so the result is 2
Dialogue: 0,0:07:58.06,0:08:00.40,English,,0,0,0,, I'm going behold that's what 5-3
Dialogue: 0,0:08:00.40,0:08:04.00,English,,0,0,0,,So it seems like magic because it is
Dialogue: 0,0:08:05.98,0:08:12.46,English,,0,0,0,,( Two's )And that's why part of the reason why I choose complement is to  the most commonly used way of representing signed numbers
Dialogue: 0,0:08:12.46,0:08:17.14,English,,0,0,0,,Because the same hardware the same algorithms that are used for doing
Dialogue: 0,0:08:18.23,0:08:23.42,English,,0,0,0,,Addition in work for either unsigned or two's complement numbers
Dialogue: 0,0:08:31.70,0:08:36.40,English,,0,0,0,,And this works as well just to show you
Dialogue: 0,0:08:36.84,0:08:42.28,English,,0,0,0,,If the overflow goes if the resulting thumb is goes the other way
Dialogue: 0,0:08:45.86,0:08:50.28,English,,0,0,0,, So if I have -3, and -5 + 3
Dialogue: 0,0:08:51.10,0:08:53.06,English,,0,0,0,,And I add those together
Dialogue: 0,0:09:03.58,0:09:07.64,English,,0,0,0,,ok,1110 which is -2
Dialogue: 0,0:09:10.16,0:09:16.56,English,,0,0,0,,So again if you use the same patterns for the same rule for addition
Dialogue: 0,0:09:17.62,0:09:22.10,English,,0,0,0,,As you do with the unsigned case you'll get two's complement arithmetic
Dialogue: 0,0:09:24.10,0:09:29.18,English,,0,0,0,, So what smoke in a few cases where the two's complement overflows
Dialogue: 0,0:09:36.04,0:09:55.02,English,,0,0,0,,So if we take -3 and -6
Dialogue: 0,0:09:55.86,0:10:00.22,English,,0,0,0,,And we add them together we'll get 1110
Dialogue: 0,0:10:00.22,0:10:03.92,English,,0,0,0,,We're going to drop off the carry, which is what?
Dialogue: 0,0:10:05.14,0:10:05.96,English,,0,0,0,,7
Dialogue: 0,0:10:08.84,0:10:11.18,English,,0,0,0,,So we've added two negative numbers
Dialogue: 0,0:10:11.70,0:10:16.46,English,,0,0,0,,And it's become positive and that's referred to as a negative overflow
Dialogue: 0,0:10:23.20,0:10:26.22,English,,0,0,0,, And the reason of course is the number -9
Dialogue: 0,0:10:26.90,0:10:32.72,English,,0,0,0,,I can't be represented in a 4-bit two's complement number so
Dialogue: 0,0:10:34.12,0:10:35.96,English,,0,0,0,,It  overflowed
Dialogue: 0,0:10:37.34,0:10:44.88,English,,0,0,0,,You'll notice that the +7 of cause differs from -9 by 16 and that's not next
Dialogue: 0,0:10:46.30,0:10:48.96,English,,0,0,0,,And then going the other direction
Dialogue: 0,0:10:49.26,0:11:09.20,English,,0,0,0,, If we had two large positive numbers so if we had 7 and 5
Dialogue: 0,0:11:09.54,0:11:11.86,English,,0,0,0,,We'll get -6
Dialogue: 0,0:11:12.82,0:11:22.34,English,,0,0,0,,So this was 7 + 5 = -4
Dialogue: 0,0:11:26.50,0:11:28.94,English,,0,0,0,,And so this is referred to as positive overflow
Dialogue: 0,0:11:28.94,0:11:42.14,English,,0,0,0,,We've taken two positive numbers and added them together and gotten a negative result
Dialogue: 0,0:11:42.44,0:11:49.20,English,,0,0,0,, And you could see this  by the way if you think about this addition we took 7 and 5 would be 12
Dialogue: 0,0:11:49.54,0:11:53.22,English,,0,0,0,,And this is the bit level representation of 12
Dialogue: 0,0:11:53.74,0:11:56.66,English,,0,0,0,, It's just that because this is now the sign bit
Dialogue: 0,0:11:57.72,0:12:01.04,English,,0,0,0,,We think of that as -4 not +12
Dialogue: 0,0:12:04.56,0:12:08.90,English,,0,0,0,,And so that's the the idea of two's complement overflow
Dialogue: 0,0:12:09.66,0:12:12.62,English,,0,0,0,,And you can see there's two different cases here
Dialogue: 0,0:12:13.48,0:12:20.28,English,,0,0,0,,One is where the number that the sum was if we looked at the true sum
Dialogue: 0,0:12:20.90,0:12:25.82,English,,0,0,0,,The number that you'd get for example 12 is too big to represent
Dialogue: 0,0:12:25.82,0:12:30.22,English,,0,0,0,,So when we think of that as a two's complement number it becomes now a negative number
Dialogue: 0,0:12:30.50,0:12:32.08,English,,0,0,0,, So that's positive overflow
Dialogue: 0,0:12:32.60,0:12:36.54,English,,0,0,0,, Similarly if we have two negative numbers and we add them together
Dialogue: 0,0:12:36.54,0:12:40.84,English,,0,0,0,, So that the sum is too small to negative to represent
Dialogue: 0,0:12:41.26,0:12:44.52,English,,0,0,0,,Then those become positive numbers that's negative overflow
Dialogue: 0,0:12:45.24,0:12:47.22,English,,0,0,0,, And you can see that in this picture
Dialogue: 0,0:12:47.86,0:12:51.26,English,,0,0,0,, The same idea as before except there's three regions
Dialogue: 0,0:12:51.86,0:12:59.58,English,,0,0,0,,This is the and by the way now you'll see our numbers range between -8 and +7
Dialogue: 0,0:13:00.54,0:13:08.40,English,,0,0,0,,And the some two's complement also range between -8 and +7
Dialogue: 0,0:13:09.56,0:13:14.86,English,,0,0,0,,But there's these three regions one is the where everything is fine
Dialogue: 0,0:13:15.86,0:13:18.64,English,,0,0,0,,It's within the representable range
Dialogue: 0,0:13:18.98,0:13:25.72,English,,0,0,0,,The other is where the sum was so far toward the negative side that it becomes positive
Dialogue: 0,0:13:26.16,0:13:30.60,English,,0,0,0,, Or where it's so high on the positive side that it becomes negative
Dialogue: 0,0:13:34.06,0:13:42.86,English,,0,0,0,,And so part of data lab you'll learn to understand these in quite precisely
Dialogue: 0,0:13:43.26,0:13:46.54,English,,0,0,0,, But then let's see idea it's a little bit counterintuitive to say
Dialogue: 0,0:13:47.14,0:13:52.10,English,,0,0,0,,You know somehow I can accept the idea that modular arithmetic for unsigned numbers
Dialogue: 0,0:13:52.10,0:13:57.02,English,,0,0,0,,There's some sort of mathematical beauty to a modular arithmetic
Dialogue: 0,0:13:57.50,0:14:08.30,English,,0,0,0,, And this is looks like kind of useless right  from a from operational characteristic
Dialogue: 0,0:14:08.66,0:14:13.70,English,,0,0,0,,But it's the way it is and we're stuck with it
Dialogue: 0,0:14:15.90,0:14:19.36,English,,0,0,0,,And multiplication is basically the same idea
Dialogue: 0,0:14:19.36,0:14:22.56,English,,0,0,0,, In fact all the operations are the basically the same idea that
Dialogue: 0,0:14:22.98,0:14:28.04,English,,0,0,0,, If you can't represent it within the word size you just take the lower w bits
Dialogue: 0,0:14:28.58,0:14:34.76,English,,0,0,0,,So all this complicated notation here is just a way of saying
Dialogue: 0,0:14:34.76,0:14:38.76,English,,0,0,0,, In principle if you take two W bit numbers and multiply them together
Dialogue: 0,0:14:39.32,0:14:45.66,English,,0,0,0,, You may need a the result may require as much as 2w bits to represent
Dialogue: 0,0:14:46.36,0:14:48.89,English,,0,0,0,, Before addition its w+1
Dialogue: 0,0:14:49.38,0:14:51.40,English,,0,0,0,,Multiplication you actually have to double
Dialogue: 0,0:14:51.40,0:14:54.64,English,,0,0,0,, Because you're potentially squaring the largest number
Dialogue: 0,0:14:55.02,0:15:03.92,English,,0,0,0,,And so again we don't want to just keep doubling our word size over and over again we'll run out of bits very quickly that way
Dialogue: 0,0:15:04.20,0:15:07.08,English,,0,0,0,,And so we just truncate it at w bits
Dialogue: 0,0:15:13.66,0:15:18.32,English,,0,0,0,,For the unsigned case it's again modular arithmetic
Dialogue: 0,0:15:18.32,0:15:21.92,English,,0,0,0,, It's something that you can kind of understand and believe
Dialogue: 0,0:15:22.50,0:15:23.66,English,,0,0,0,,But for...
Dialogue: 0,0:15:25.94,0:15:35.32,English,,0,0,0,,And so again let's just do a few examples and I won't try and work out multiplying in binary is like multiplying in decimal
Dialogue: 0,0:15:35.76,0:15:39.72,English,,0,0,0,,You do a big table and it takes a long time so I won't try to do that
Dialogue: 0,0:15:40.30,0:15:44.30,English,,0,0,0,,But let me just show a few examples
Dialogue: 0,0:15:53.68,0:15:59.20,English,,0,0,0,,So if I multiply 3 * 5 is of cause equal to 15
Dialogue: 0,0:16:00.06,0:16:06.22,English,,0,0,0,,And in an unsigned number I can represent that right
Dialogue: 0,0:16:06.80,0:16:08.46,English,,0,0,0,,So that's okay
Dialogue: 0,0:16:13.60,0:16:16.32,English,,0,0,0,,But if I multiply a 5*5
Dialogue: 0,0:16:22.40,0:16:25.40,English,,0,0,0,,Then that would have representation
Dialogue: 0,0:16:28.04,0:16:31.26,English,,0,0,0,,If I were to think about it as possibly as many as 8 bits
Dialogue: 0,0:16:31.26,0:16:39.80,English,,0,0,0,,It would have a representation with an extra bit
Dialogue: 0,0:16:40.50,0:16:42.42,English,,0,0,0,,And I'm going to throw this part away
Dialogue: 0,0:16:42.74,0:16:44.40,English,,0,0,0,,And so I'd call that 9
Dialogue: 0,0:16:45.28,0:16:47.98,English,,0,0,0,,Which of cause is equal to 25 mod 16
Dialogue: 0,0:16:54.84,0:17:01.16,English,,0,0,0,,And so that's the general idea of it is regardless of whatever's in this upper part of the word
Dialogue: 0,0:17:01.30,0:17:05.26,English,,0,0,0,,The product I'm just going to discard that and only look at the lower one
Dialogue: 0,0:17:05.78,0:17:09.70,English,,0,0,0,,And life gets a little more interesting with the two's complement case
Dialogue: 0,0:17:10.60,0:17:12.28,English,,0,0,0,, So let's look at what that does
Dialogue: 0,0:17:14.98,0:17:16.86,English,,0,0,0,,And the answer is
Dialogue: 0,0:17:18.24,0:17:19.94,English,,0,0,0,,Even a little bit stranger
Dialogue: 0,0:17:19.94,0:17:25.88,English,,0,0,0,,That you not only trunk throw away whatever high order bits happen to be there
Dialogue: 0,0:17:26.34,0:17:32.42,English,,0,0,0,, But whatever bit gets left in this position will determine whether it's a positive or a negative result
Dialogue: 0,0:17:33.45,0:17:39.88,English,,0,0,0,,Even though with completely irrespective of the signs of the original two operands
Dialogue: 0,0:17:40.96,0:17:44.46,English,,0,0,0,,So that can make you go all over the place
Dialogue: 0,0:18:02.60,0:18:07.70,English,,0,0,0,,so if we had 5*4 of 20
Dialogue: 0,0:18:08.94,0:18:24.08,English,,0,0,0,,That would be represented in this 8-bit form like so
Dialogue: 0,0:18:24.68,0:18:28.92,English,,0,0,0,,And we just call that 4 right
Dialogue: 0,0:18:29.40,0:18:30.84,English,,0,0,0,,Because we throwing this away
Dialogue: 0,0:18:31.34,0:18:41.64,English,,0,0,0,,But if we did 5*5 as we saw before that's represented like this
Dialogue: 0,0:18:50.22,0:18:51.38,English,,0,0,0,,And that's sum...
Dialogue: 0,0:18:52.72,0:18:54.08,English,,0,0,0,, Now becomes...
Dialogue: 0,0:18:54.28,0:18:55.64,English,,0,0,0,,So we're throwing away this
Dialogue: 0,0:18:56.08,0:19:02.08,English,,0,0,0,,And this becomes our sign bit so the result is a -8 + 1= -7
Dialogue: 0,0:19:05.70,0:19:11.60,English,,0,0,0,,So you see this is a similar to an example we showed at the beginning of the first lecture
Dialogue: 0,0:19:11.62,0:19:16.18,English,,0,0,0,,You can have two positive numbers and multiply them and get a negative result
Dialogue: 0,0:19:18.08,0:19:20.94,English,,0,0,0,,Because of the sort of quirks of this overflow
Dialogue: 0,0:19:20.94,0:19:21.66,English,,0,0,0,, Question that
Dialogue: 0,0:19:21.66,0:19:23.66,English,,0,0,0,,[student speaking]
Dialogue: 0,0:19:24.80,0:19:27.98,English,,0,0,0,,Oh I'm just taking 25 and writing it in binary
Dialogue: 0,0:19:28.04,0:19:30.38,English,,0,0,0,,[student speaking]
Dialogue: 0,0:19:30.38,0:19:34.68,English,,0,0,0,,Yeah if you want to you know you start with the two numbers
Dialogue: 0,0:19:36.82,0:19:40.62,English,,0,0,0,,I'm not going to do well actually this one's an easy one there's a trick for this
Dialogue: 0,0:19:41.20,0:19:44.00,English,,0,0,0,,If you want to know multiply a number by a power-of-2
Dialogue: 0,0:19:44.50,0:19:49.94,English,,0,0,0,,We're going to show that later you just shift it left by two positions
Dialogue: 0,0:19:54.92,0:19:56.22,English,,0,0,0,, So that one's an easy one
Dialogue: 0,0:19:56.22,0:20:00.86,English,,0,0,0,,Otherwise you have to write out the table and sum all the results and all that stuff
Dialogue: 0,0:20:02.42,0:20:06.32,English,,0,0,0,,I prefer to what computers do that
Dialogue: 0,0:20:14.40,0:20:22.84,English,,0,0,0,,And again this two's complement stuff one interesting feature is that it works for our negative numbers too
Dialogue: 0,0:20:23.82,0:20:27.56,English,,0,0,0,,If you do this trick of throwing away the high-order bits
Dialogue: 0,0:20:28.24,0:20:33.10,English,,0,0,0,,And you'll have overflow cases like before because you're throwing away information
Dialogue: 0,0:20:33.10,0:20:38.74,English,,0,0,0,,But the lower bits if the number is representable you'll get the right result
Dialogue: 0,0:20:38.74,0:20:41.64,English,,0,0,0,,So let me just demonstrate to that to you
Dialogue: 0,0:20:45.26,0:20:47.32,English,,0,0,0,, So this is -3
Dialogue: 0,0:20:48.18,0:20:53.40,English,,0,0,0,,But you remember that this is equivalent to 13 as an unsigned number
Dialogue: 0,0:20:54.78,0:21:05.78,English,,0,0,0,,And this is -2 which is equivalent to 14 as an unsigned number
Dialogue: 0,0:21:06.78,0:21:13.54,English,,0,0,0,,So now if we multiply 13*14, you get 182
Dialogue: 0,0:21:15.24,0:21:18.60,English,,0,0,0,, And that has a hex representation of 0xb6
Dialogue: 0,0:21:28.76,0:21:34.24,English,,0,0,0,,And so just looking at the low-order for bits are 0110 is 6
Dialogue: 0,0:21:34.90,0:21:39.44,English,,0,0,0,,And indeed that's -3*-2 is 6
Dialogue: 0,0:21:39.72,0:21:43.98,English,,0,0,0,,So the point being oh and I'm waving my hands here
Dialogue: 0,0:21:43.98,0:21:46.60,English,,0,0,0,,Because I don't want to go through all the details
Dialogue: 0,0:21:46.92,0:21:50.80,English,,0,0,0,,But two's complement multiplication also gives you
Dialogue: 0,0:21:51.88,0:21:54.70,English,,0,0,0,,If you can do it using the exact same rules
Dialogue: 0,0:21:55.48,0:21:59.39,English,,0,0,0,, And as you do for unsigned multiplication the exact same hardware
Dialogue: 0,0:21:59.74,0:22:04.88,English,,0,0,0,,I should mention that and there are instructions in the computer
Dialogue: 0,0:22:04.88,0:22:09.10,English,,0,0,0,,In ways that you can get the upper word of a multiplication too
Dialogue: 0,0:22:09.50,0:22:12.70,English,,0,0,0,,And those the bit patterns are different depending on whether
Dialogue: 0,0:22:13.72,0:22:16.46,English,,0,0,0,,it's treated as a two's complement number versus unsigned
Dialogue: 0,0:22:16.46,0:22:20.64,English,,0,0,0,,So these typically different instructions for doing that computation
Dialogue: 0,0:22:20.94,0:22:27.72,English,,0,0,0,, But 99% of the time or more you just are looking at this lower part of the product
Dialogue: 0,0:22:27.72,0:22:31.36,English,,0,0,0,,And that's the same whether it's a two's complement or an unsigned
Dialogue: 0,0:22:33.42,0:22:38.12,English,,0,0,0,, And it handles negative numbers positive but it has these overflow characteristics
Dialogue: 0,0:22:43.42,0:22:50.38,English,,0,0,0,,So as I was talking about there's a trick we can do for multiplying by a power-of-2
Dialogue: 0,0:22:50.80,0:22:52.98,English,,0,0,0,,Which is just to shift the number to the left
Dialogue: 0,0:22:53.32,0:22:56.42,English,,0,0,0,,And you'll often see that when you have in your code
Dialogue: 0,0:22:56.76,0:23:01.16,English,,0,0,0,, I want to multiply some number by 4 you'll write it in your C code
Dialogue: 0,0:23:01.44,0:23:04.12,English,,0,0,0,,If you look at the assembly code you'll see that what
Dialogue: 0,0:23:04.18,0:23:08.42,English,,0,0,0,,The compiler generated is just says oh just shift it left by 2
Dialogue: 0,0:23:09.22,0:23:11.98,English,,0,0,0,,So in general and you could see why this is true
Dialogue: 0,0:23:11.98,0:23:34.04,English,,0,0,0,,By the way if you think of the number as the sum of the bits
Dialogue: 0,0:23:34.04,0:23:38.32,English,,0,0,0,,Where X sub I is the if--but and X is the number it represents
Dialogue: 0,0:23:38.88,0:23:43.92,English,,0,0,0,,If I want to if I shift everything left by 2
Dialogue: 0,0:23:44.12,0:23:50.30,English,,0,0,0,,What I'm effectively doing is increasing their weight by that number of positions
Dialogue: 0,0:23:51.16,0:23:55.98,English,,0,0,0,,So let's just shift by one if I shift everything to the left by one
Dialogue: 0,0:24:01.26,0:24:05.90,English,,0,0,0,,Which we write like this and see two left two less symbols
Dialogue: 0,0:24:10.36,0:24:15.72,English,,0,0,0,,It's like taking that sum but now weighting the bits by two to the i+1 by one more
Dialogue: 0,0:24:16.12,0:24:20.90,English,,0,0,0,,And of cause that's equal to twice what the original sum was
Dialogue: 0,0:24:23.72,0:24:25.12,English,,0,0,0,, And so we double the number
Dialogue: 0,0:24:27.48,0:24:34.88,English,,0,0,0,,And that works also even if you shift things
Dialogue: 0,0:24:35.06,0:24:38.62,English,,0,0,0,,So that you lose some bits right they they shift off to the left
Dialogue: 0,0:24:39.10,0:24:45.58,English,,0,0,0,,All you're doing is the way multiplication works anyhow of truncating to w bit product 
Dialogue: 0,0:24:45.76,0:24:52.64,English,,0,0,0,,So you'll see this as I mentioned quite often in in compiled code machine level code
Dialogue: 0,0:24:52.64,0:24:56.70,English,,0,0,0,,That they're doing shifts where you might expect them to be doing multiplications
Dialogue: 0,0:24:57.14,0:25:05.12,English,,0,0,0,,And the reason for that as an optimization is historically the multiplication instruction took a lot longer than a shift instruction 
Dialogue: 0,0:25:05.80,0:25:09.00,English,,0,0,0,,Say one clock cycle to do a shift
Dialogue: 0,0:25:09.54,0:25:15.60,English,,0,0,0,,And it used to be like 11,12,13 clock cycles to do a multiplication
Dialogue: 0,0:25:15.92,0:25:18.46,English,,0,0,0,,Nowadays like on computers
Dialogue: 0,0:25:20.28,0:25:24.44,English,,0,0,0,,We use the shark machines it only takes three clock cycles to do multiplication
Dialogue: 0,0:25:24.44,0:25:27.46,English,,0,0,0,,Because they added a lot of hardware to do that
Dialogue: 0,0:25:27.96,0:25:31.78,English,,0,0,0,,But three clock cycles is still more time than one
Dialogue: 0,0:25:32.18,0:25:36.42,English,,0,0,0,,And so when you can get away with a shift it's generally a better idea
Dialogue: 0,0:25:36.42,0:25:41.20,English,,0,0,0,,And the compiler has its own kind of judgment calls on
Dialogue: 0,0:25:41.20,0:25:46.36,English,,0,0,0,,When is it more efficient to substitute one up for another
Dialogue: 0,0:25:51.36,0:25:53.54,English,,0,0,0,, Did we, did I lose ground here?
Dialogue: 0,0:26:00.74,0:26:10.14,English,,0,0,0,, Okay so the idea that if we want to multiply something by 2^k
Dialogue: 0,0:26:10.44,0:26:12.58,English,,0,0,0,,We just shift it left by k bit
Dialogue: 0,0:26:19.04,0:26:24.78,English,,0,0,0,, It turns out that the same almost works for dividing by 2 as well
Dialogue: 0,0:26:24.80,0:26:32.98,English,,0,0,0,,That if you want to divide something by a power-of-2 you can shift it right by this in the same general
Dialogue: 0,0:26:33.52,0:26:36.56,English,,0,0,0,,The only thing that becomes a little bit quirky is
Dialogue: 0,0:26:36.92,0:26:42.12,English,,0,0,0,,Well what if the number you have is not actually divisible by that power-of-2
Dialogue: 0,0:26:51.36,0:26:55.02,English,,0,0,0,,So for example if we had the number 01
Dialogue: 0,0:26:58.14,0:27:01.58,English,,0,0,0,,I want. I'm going to use this
Dialogue: 0,0:27:07.48,0:27:09.74,English,,0,0,0,,Yeah so that's 6
Dialogue: 0,0:27:10.90,0:27:17.46,English,,0,0,0,,So if we shift it right by one we'll get 0010
Dialogue: 0,0:27:19.88,0:27:21.26,English,,0,0,0,, (00)11 thank you
Dialogue: 0,0:27:22.12,0:27:26.06,English,,0,0,0,,Which is 3 and that's 6/3=2
Dialogue: 0,0:27:26.28,0:27:27.76,English,,0,0,0,, If we shift that again
Dialogue: 0,0:27:32.10,0:27:37.78,English,,0,0,0,,We'll get 1.But of cause you know that three-halves or 1.5
Dialogue: 0,0:27:39.24,0:27:46.08,English,,0,0,0,,The rule on integer division is you round it down round it toward 0
Dialogue: 0,0:27:47.40,0:27:49.96,English,,0,0,0,,And so that goes to 1 so
Dialogue: 0,0:27:50.90,0:27:54.40,English,,0,0,0,,This is what the unsigned case works fine
Dialogue: 0,0:27:55.30,0:28:00.80,English,,0,0,0,, The signed case which I don't have a slide for
Dialogue: 0,0:28:05.84,0:28:09.80,English,,0,0,0,, Is a little bit less of pretty
Dialogue: 0,0:28:11.34,0:28:17.28,English,,0,0,0,,Well first of all you notice if it's a positive number the shifting rights going to be the right
Dialogue: 0,0:28:18.44,0:28:20.20,English,,0,0,0,,Just as is for unsigned
Dialogue: 0,0:28:20.34,0:28:28.08,English,,0,0,0,,But let's take a number that is negative
Dialogue: 0,0:28:28.52,0:28:34.70,English,,0,0,0,,So this is -6 right
Dialogue: 0,0:28:34.82,0:28:40.42,English,,0,0,0,,Now here's where remember I told you in the previous lecture
Dialogue: 0,0:28:40.42,0:28:45.80,English,,0,0,0,, There's two ways to do shifting there is logical shifting where you fill in with 0
Dialogue: 0,0:28:46.22,0:28:49.80,English,,0,0,0,,And arithmetic shifting where you fill in with ones
Dialogue: 0,0:28:50.68,0:28:56.92,English,,0,0,0,,And guess where arithmetic shifting comes in this is it
Dialogue: 0,0:28:57.42,0:29:00.68,English,,0,0,0,,When you want to preserve the sign of a number
Dialogue: 0,0:29:00.88,0:29:04.92,English,,0,0,0,,while you're dividing it by power-of-2 you want arithmetic shifts
Dialogue: 0,0:29:05.64,0:29:09.94,English,,0,0,0,,So if we shift this by one we'll keep that sign bit
Dialogue: 0,0:29:10.64,0:29:15.48,English,,0,0,0,,And then copy the other ones over right
Dialogue: 0,0:29:15.50,0:29:21.16,English,,0,0,0,,So we just preserve this bit here and copied the other ones over
Dialogue: 0,0:29:22.36,0:29:28.10,English,,0,0,0,, And this is -3.And so that's good
Dialogue: 0,0:29:28.84,0:29:31.32,English,,0,0,0,,But now if we shift again arithmetic
Dialogue: 0,0:29:34.44,0:29:42.24,English,,0,0,0,, We will get what? -2
Dialogue: 0,0:29:42.64,0:29:46.52,English,,0,0,0,,I can see you guys need to know how to negate numbers right
Dialogue: 0,0:29:46.52,0:29:49.46,English,,0,0,0,,You don't know that so I'll show you in a second
Dialogue: 0,0:29:50.02,0:29:53.94,English,,0,0,0,,So here is a little bit problematic that we shifted
Dialogue: 0,0:29:54.88,0:29:56.86,English,,0,0,0,,We want to divide by two
Dialogue: 0,0:29:58.08,0:30:01.76,English,,0,0,0,,But the rule should be the same that you should round toward zero
Dialogue: 0,0:30:02.10,0:30:04.86,English,,0,0,0,,And what this is doing is it's rounding toward
Dialogue: 0,0:30:05.32,0:30:11.04,English,,0,0,0,,Minus infinity it's rounding toward a more negative number than the the true thing
Dialogue: 0,0:30:12.76,0:30:15.10,English,,0,0,0,,And so there's a little cute little trick
Dialogue: 0,0:30:17.08,0:30:23.08,English,,0,0,0,, That says before you shift before you divide by a power-of-2 before you do the shift
Dialogue: 0,0:30:23.90,0:30:25.22,English,,0,0,0,,You should add a bias
Dialogue: 0,0:30:31.64,0:30:34.00,English,,0,0,0,,Which in this case would just be one
Dialogue: 0,0:30:34.00,0:30:36.06,English,,0,0,0,,You know and I'll tell you where that comes from
Dialogue: 0,0:30:36.48,0:30:45.70,English,,0,0,0,, And so if we add those numbers together we'll get 1110 right
Dialogue: 0,0:30:46.10,0:30:52.78,English,,0,0,0,,And now when we do the shift on that we'll get 1111
Dialogue: 0,0:30:53.74,0:30:55.24,English,,0,0,0,,And that's -1
Dialogue: 0,0:30:55.64,0:30:59.30,English,,0,0,0,,So there's a trick and you'll again you'll see the compiler doing this where
Dialogue: 0,0:31:00.00,0:31:04.14,English,,0,0,0,,You have in your code divided by 16 and we'll add a bias
Dialogue: 0,0:31:04.38,0:31:07.60,English,,0,0,0,,And then it will do a right shift instead of calling division
Dialogue: 0,0:31:07.72,0:31:13.68,English,,0,0,0,,And by the way division really really is slow even on a modern computer like what you have
Dialogue: 0,0:31:13.98,0:31:19.00,English,,0,0,0,,The shark machines it takes 30 plus Hawk cycles
Dialogue: 0,0:31:19.44,0:31:23.14,English,,0,0,0,,So anytime the compiler can avoid figure out a trick
Dialogue: 0,0:31:23.14,0:31:26.86,English,,0,0,0,,That does it with shifting and tweaking things around it will
Dialogue: 0,0:31:28.14,0:31:31.38,English,,0,0,0,,Oh so I realize I should tell you
Dialogue: 0,0:31:31.38,0:31:36.86,English,,0,0,0,,There's a couple ways you can negate a number
Dialogue: 0,0:31:36.86,0:31:41.58,English,,0,0,0,,That are handy to know if you ever have to do it in your head or on paper
Dialogue: 0,0:31:43.70,0:31:46.74,English,,0,0,0,, And the standard way is what's called complement and increment
Dialogue: 0,0:31:47.26,0:31:51.88,English,,0,0,0,,So this is how do I go from X to -X
Dialogue: 0,0:31:52.68,0:31:59.44,English,,0,0,0,,So if I have a number and I want to negate it
Dialogue: 0,0:31:59.48,0:32:04.82,English,,0,0,0,,Whether it's currently a negative number or it's a positive number the same trick works
Dialogue: 0,0:32:05.08,0:32:07.86,English,,0,0,0,,What I'll do is complement it meaning I'll flip all the bits
Dialogue: 0,0:32:11.64,0:32:18.98,English,,0,0,0,,And then I'll add one to that
Dialogue: 0,0:32:18.98,0:32:25.32,English,,0,0,0,, And do the regular sum
Dialogue: 0,0:32:25.32,0:32:30.61,English,,0,0,0,, And so this is 6,this is -6
Dialogue: 0,0:32:31.48,0:32:33.24,English,,0,0,0,,So if you ever have to do it by hand
Dialogue: 0,0:32:33.24,0:32:36.54,English,,0,0,0,,That's the way to do it complement and increment  and it goes the other way
Dialogue: 0,0:32:37.02,0:32:38.62,English,,0,0,0,,You'll see if I compliment this 
Dialogue: 0,0:32:44.58,0:32:51.84,English,,0,0,0,,And I increment it I'll get back to my previous number
Dialogue: 0,0:32:52.14,0:32:53.44,English,,0,0,0,,So that's a trick
Dialogue: 0,0:32:56.28,0:32:59.68,English,,0,0,0,,That is pretty much only useful when you do things on the blackboard
Dialogue: 0,0:32:59.88,0:33:02.60,English,,0,0,0,,Or when you have to solve a problem in data lab
Dialogue: 0,0:33:13.02,0:33:21.36,English,,0,0,0,,Anyways the this idea of doing a using up shifting to the right to do power-of-2 division
Dialogue: 0,0:33:21.36,0:33:25.58,English,,0,0,0,, is actually that's the whole justification for arithmetic shifting in the first place
Dialogue: 0,0:33:25.98,0:33:31.68,English,,0,0,0,,Which by the way in and see there's no fixed requirement
Dialogue: 0,0:33:31.68,0:33:35.88,English,,0,0,0,,For how shifting works in c for signed numbers
Dialogue: 0,0:33:35.88,0:33:38.20,English,,0,0,0,,For unsigned it has to be a logical shift
Dialogue: 0,0:33:38.74,0:33:43.50,English,,0,0,0,,Sign numbers the C standard says there's no fixed definition
Dialogue: 0,0:33:43.74,0:33:48.56,English,,0,0,0,, The reality is on our machines most machines just about every machine out there
Dialogue: 0,0:33:49.24,0:33:55.14,English,,0,0,0,,When it's a two's complement number when it's a negative where it's the signed number it's two's complement
Dialogue: 0,0:33:55.40,0:33:58.12,English,,0,0,0,,And when you do a shift it will be an arithmetic shift
Dialogue: 0,0:34:07.22,0:34:11.44,English,,0,0,0,,So getting back to them summarizing this integer arithmetic
Dialogue: 0,0:34:11.90,0:34:15.79,English,,0,0,0,,You see that first of all whether it's signed your unsigned
Dialogue: 0,0:34:16.22,0:34:21.64,English,,0,0,0,,The addition or multiplication operations are the same
Dialogue: 0,0:34:22.00,0:34:25.84,English,,0,0,0,,Whether it's a unsigned number or two's complement
Dialogue: 0,0:34:27.06,0:34:31.02,English,,0,0,0,,And it works the negative stuff works out
Dialogue: 0,0:34:31.58,0:34:33.98,English,,0,0,0,,As long as you don't have an overflow
Dialogue: 0,0:34:34.38,0:34:36.56,English,,0,0,0,,And you can end up with an overflow
Dialogue: 0,0:34:38.48,0:34:43.02,English,,0,0,0,,Only one type of overflow for unsigned and two types for signed numbers
Dialogue: 0,0:34:43.64,0:34:48.26,English,,0,0,0,, But it's not like they just overflow on generate random numbers
Dialogue: 0,0:34:48.26,0:34:54.24,English,,0,0,0,,There is some a pattern to what result what they are and how they can be interpreted
Dialogue: 0,0:35:01.72,0:35:07.46,English,,0,0,0,,So we I talked about this a little bit last time and gave this example similar to this
Dialogue: 0,0:35:07.46,0:35:09.58,English,,0,0,0,,But let me go over it a little bit more
Dialogue: 0,0:35:10.94,0:35:17.42,English,,0,0,0,,One thing you might think of wow if this unsigned and signed stuff gets so murky
Dialogue: 0,0:35:17.46,0:35:19.98,English,,0,0,0,,And we saw some funny examples last time
Dialogue: 0,0:35:20.34,0:35:24.92,English,,0,0,0,, Maybe we should just banished unsigned numbers from the universe
Dialogue: 0,0:35:25.40,0:35:27.12,English,,0,0,0,, And only allow two's complement
Dialogue: 0,0:35:27.44,0:35:31.92,English,,0,0,0,,And that's exactly the rule that was adopted for example in Java
Dialogue: 0,0:35:31.92,0:35:34.24,English,,0,0,0,,They said is too weird
Dialogue: 0,0:35:35.98,0:35:38.86,English,,0,0,0,,What let's just say every number is two's complement
Dialogue: 0,0:35:39.22,0:35:47.92,English,,0,0,0,, The only trick they did was they put in a triple right shift
Dialogue: 0,0:35:51.18,0:35:54.52,English,,0,0,0,,Means logical shift this is Java this is not C
Dialogue: 0,0:36:02.16,0:36:12.40,English,,0,0,0,, Whereas the double is a arithmetic
Dialogue: 0,0:36:13.74,0:36:18.00,English,,0,0,0,,So because they realized there's a lot of cute little times
Dialogue: 0,0:36:18.00,0:36:20.18,English,,0,0,0,,When you want to play tricks with things
Dialogue: 0,0:36:20.50,0:36:22.94,English,,0,0,0,,And you need that logical right shift
Dialogue: 0,0:36:23.96,0:36:29.52,English,,0,0,0,,So that's actually one approach or other more modern languages and C are saying
Dialogue: 0,0:36:29.82,0:36:31.92,English,,0,0,0,,It's okay to have signed and unsigned
Dialogue: 0,0:36:32.16,0:36:35.96,English,,0,0,0,,But we don't want them sort of mysteriously being cast back and forth 
Dialogue: 0,0:36:35.96,0:36:38.82,English,,0,0,0,,In ways that the programmer might not recognize
Dialogue: 0,0:36:38.82,0:36:43.70,English,,0,0,0,, And so you have to explicitly do a cast rather than implicitly
Dialogue: 0,0:36:44.24,0:36:45.86,English,,0,0,0,, And I think that's the better approach
Dialogue: 0,0:36:45.86,0:36:49.74,English,,0,0,0,, But C as I mentioned does this implicit casting
Dialogue: 0,0:36:50.00,0:36:55.28,English,,0,0,0,,And so as we saw for last time what happens with this program when you run it
Dialogue: 0,0:36:59.15,0:37:08.89,English,,0,0,0,,To count down through an array do you remember?
Dialogue: 0,0:37:09.24,0:37:14.94,English,,0,0,0,,Well as I if it's unsigned what will happen with this test
Dialogue: 0,0:37:16.58,0:37:19.64,English,,0,0,0,,It always succeeds so the thing will be in an infinite loop
Dialogue: 0,0:37:20.18,0:37:22.68,English,,0,0,0,,Actually what will happen is it will try to access
Dialogue: 0,0:37:23.38,0:37:27.66,English,,0,0,0,,I will go down to 0 and then it will wrap around to become
Dialogue: 0,0:37:28.22,0:37:30.14,English,,0,0,0,, The largest possible unsigned number
Dialogue: 0,0:37:30.14,0:37:34.08,English,,0,0,0,,Which is probably way out of bounds and it will give a memory error
Dialogue: 0,0:37:35.34,0:37:37.64,English,,0,0,0,,But it won't do what's supposed to be
Dialogue: 0,0:37:37.82,0:37:42.67,English,,0,0,0,,And as I mentioned before these things there is a lot of sneaky ways this problem can show up
Dialogue: 0,0:37:43.00,0:37:44.90,English,,0,0,0,, In ways you might never think of
Dialogue: 0,0:37:45.28,0:37:55.16,English,,0,0,0,,So for example the operator sizeof is defined to say how big a particular datatype is
Dialogue: 0,0:37:55.86,0:37:57.38,English,,0,0,0,,It's a very useful operator
Dialogue: 0,0:37:57.38,0:38:03.48,English,,0,0,0,, But it's its return value is a what's called a size underscore t
Dialogue: 0,0:38:03.48,0:38:07.12,English,,0,0,0,,Which is defined to be a long unsigned number
Dialogue: 0,0:38:07.70,0:38:12.88,English,,0,0,0,, And so if we just throw in a constant like this
Dialogue: 0,0:38:13.14,0:38:17.02,English,,0,0,0,, Then this subtraction we have a sign in is now int
Dialogue: 0,0:38:17.54,0:38:19.60,English,,0,0,0,,But sizeof is unsigned
Dialogue: 0,0:38:19.86,0:38:23.38,English,,0,0,0,,And so it will cast that to be unsigned implicitly
Dialogue: 0,0:38:24.15,0:38:28.06,English,,0,0,0,,And when you compare it to 0 you'll have the same problem as before
Dialogue: 0,0:38:29.40,0:38:35.00,English,,0,0,0,, So just to show you that these things can sneak in very tricky ways
Dialogue: 0,0:38:35.46,0:38:41.86,English,,0,0,0,,So one way to do that then is just don't use unsigned like
Dialogue: 0,0:38:41.92,0:38:47.14,English,,0,0,0,,And make sure if this is a a possible
Dialogue: 0,0:38:48.26,0:38:51.36,English,,0,0,0,,Unsigned number you cast it to signed
Dialogue: 0,0:38:51.70,0:38:54.34,English,,0,0,0,,You make sure this is recognized and signed
Dialogue: 0,0:38:54.94,0:38:57.72,English,,0,0,0,, But there's another way that actually
Dialogue: 0,0:38:57.96,0:39:02.40,English,,0,0,0,, At least there's a fellow over the software engineering Institute named Robert Seacord
Dialogue: 0,0:39:03.02,0:39:12.88,English,,0,0,0,, Who has written the books that are suited to considered the  this the gold standard for how to write secure code
Dialogue: 0,0:39:13.20,0:39:16.82,English,,0,0,0,,He works for this organization called the computer emergency response team
Dialogue: 0,0:39:16.82,0:39:24.72,English,,0,0,0,, Which is out there tracking down bad things going on in computer security
Dialogue: 0,0:39:25.18,0:39:30.20,English,,0,0,0,,And one of the things he and others have done is to try and come up with standards
Dialogue: 0,0:39:30.20,0:39:36.04,English,,0,0,0,, So that people who write programs will you know avoid some of the pitfalls
Dialogue: 0,0:39:36.04,0:39:40.74,English,,0,0,0,, That make their programs vulnerable to the security of was to attack
Dialogue: 0,0:39:41.24,0:39:44.62,English,,0,0,0,, And so his recommended technique is when I first saw this
Dialogue: 0,0:39:44.62,0:39:46.70,English,,0,0,0,,It was so counterintuitive to me
Dialogue: 0,0:39:47.46,0:39:52.36,English,,0,0,0,,It hardly made sense right
Dialogue: 0,0:39:52.48,0:39:55.62,English,,0,0,0,,So you start and again this is all unsigned arithmetic
Dialogue: 0,0:39:55.84,0:39:58.18,English,,0,0,0,, So I'm starting to count down
Dialogue: 0,0:39:58.42,0:40:01.50,English,,0,0,0,,And my test is when I is less than count
Dialogue: 0,0:40:02.40,0:40:05.62,English,,0,0,0,,So here's the thing I started off smaller than count
Dialogue: 0,0:40:06.14,0:40:10.58,English,,0,0,0,,And it's only being decremented so when would this test ever fail
Dialogue: 0,0:40:10.58,0:40:15.68,English,,0,0,0,,[student question]
Dialogue: 0,0:40:15.84,0:40:17.92,English,,0,0,0,,When it overflows when it wraps around
Dialogue: 0,0:40:18.26,0:40:23.30,English,,0,0,0,, Right when I goes from zero and counts down to what would now be UMax
Dialogue: 0,0:40:24.28,0:40:27.82,English,,0,0,0,,This test will fail which is exactly when you want it to stop
Dialogue: 0,0:40:28.60,0:40:35.60,English,,0,0,0,,And his observation is and in C with signed numbers there's no guarantee on what happens with overflowing
Dialogue: 0,0:40:35.68,0:40:39.68,English,,0,0,0,,As I said most people just assume it's going to be two's complement
Dialogue: 0,0:40:39.68,0:40:41.64,English,,0,0,0,,But if you really want to be careful
Dialogue: 0,0:40:41.90,0:40:45.04,English,,0,0,0,,You shouldn't assume anything outside of the C standard
Dialogue: 0,0:40:45.30,0:40:47.24,English,,0,0,0,,And if you're trying to write secure code
Dialogue: 0,0:40:47.54,0:40:51.12,English,,0,0,0,, It's probably a good idea to be cautious be conservative
Dialogue: 0,0:40:52.16,0:40:55.46,English,,0,0,0,,On the other hand the C standard guarantees
Dialogue: 0,0:40:55.94,0:41:00.50,English,,0,0,0,,That unsigned arithmetic will be modular arithmetic so it guarantees
Dialogue: 0,0:41:00.68,0:41:05.48,English,,0,0,0,,If you subtract one from zero you'll get the largest number that could be represented
Dialogue: 0,0:41:05.96,0:41:09.16,English,,0,0,0,,So it will be okay
Dialogue: 0,0:41:09.36,0:41:13.40,English,,0,0,0,,And in fact he recommends instead of using unsigned
Dialogue: 0,0:41:13.40,0:41:16.92,English,,0,0,0,,Which is on our machines just a 32-bit value
Dialogue: 0,0:41:17.86,0:41:21.92,English,,0,0,0,, That you call it a size_t which is a 64-bit value
Dialogue: 0,0:41:22.44,0:41:26.64,English,,0,0,0,, And so and write your code the way that I showed you
Dialogue: 0,0:41:27.74,0:41:29.48,English,,0,0,0,,So I've actually started doing this
Dialogue: 0,0:41:29.98,0:41:33.50,English,,0,0,0,,And once you kind of get used to it it it's an OK way to write code
Dialogue: 0,0:41:33.50,0:41:36.42,English,,0,0,0,,But it's very strange-looking initial
Dialogue: 0,0:41:37.43,0:41:44.14,English,,0,0,0,,One thing I'll point out is
Dialogue: 0,0:41:44.24,0:41:50.64,English,,0,0,0,,What would happen if count were a signed number int
Dialogue: 0,0:41:52.08,0:41:57.50,English,,0,0,0,,And it were you were up and it was less than zero what would happen here
Dialogue: 0,0:42:01.80,0:42:04.58,English,,0,0,0,,So I less than count what would happen
Dialogue: 0,0:42:05.06,0:42:10.72,English,,0,0,0,, [student question]
Dialogue: 0,0:42:10.72,0:42:14.46,English,,0,0,0,,Right and so it become a very large positive number
Dialogue: 0,0:42:14.86,0:42:16.98,English,,0,0,0,,And this test would almost certainly succeed
Dialogue: 0,0:42:17.04,0:42:20.58,English,,0,0,0,, So you have the same this code doesn't avoid the pitfall
Dialogue: 0,0:42:21.00,0:42:22.54,English,,0,0,0,,It just shifts it to saying
Dialogue: 0,0:42:23.26,0:42:30.46,English,,0,0,0,,You better make sure you don't you know just for this case beforehand before you get into it
Dialogue: 0,0:42:32.48,0:42:41.14,English,,0,0,0,,So I think part of it is the observation that man if you want to be careful and write code that
Dialogue: 0,0:42:41.66,0:42:48.72,English,,0,0,0,,That is guaranteed correct no matter what implementation goes on as long as it's within the C standard 
Dialogue: 0,0:42:49.16,0:42:51.46,English,,0,0,0,,It's pretty tricky business.question up there 
Dialogue: 0,0:42:52.12,0:42:59.46,English,,0,0,0,,[student question]
Dialogue: 0,0:42:59.84,0:43:04.42,English,,0,0,0,,Yes!Which is unfortunate right
Dialogue: 0,0:43:04.42,0:43:06.22,English,,0,0,0,,So yes that's exactly the rule
Dialogue: 0,0:43:06.22,0:43:10.88,English,,0,0,0,,That it's implicitly silently the C compiler doesn't give any warnings
Dialogue: 0,0:43:11.24,0:43:14.48,English,,0,0,0,, You'll never know it cast it to unsigned and
Dialogue: 0,0:43:14.90,0:43:20.62,English,,0,0,0,, As these examples show when you stare at that code and you think about it
Dialogue: 0,0:43:21.36,0:43:23.26,English,,0,0,0,, It's really easy to have bugs
Dialogue: 0,0:43:23.26,0:43:28.22,English,,0,0,0,,That you just you can look at it a thousand times and not realize that it's a bug
Dialogue: 0,0:43:28.38,0:43:33.73,English,,0,0,0,,It's a very...and there's examples these examples in the book of
Dialogue: 0,0:43:33.73,0:43:41.56,English,,0,0,0,,Of security flaws in sort of very important library software due to this problem exactly
Dialogue: 0,0:43:45.26,0:43:49.52,English,,0,0,0,,So part of the reason we teach in the course is just so you appreciate that
Dialogue: 0,0:43:49.78,0:43:54.86,English,,0,0,0,,This is a quirk in this and see that again
Dialogue: 0,0:43:54.86,0:43:59.84,English,,0,0,0,,99% of the time you'll never even it won't bother you at all
Dialogue: 0,0:43:59.84,0:44:03.50,English,,0,0,0,,But there will be some oddball cases that you can get in trouble with
Dialogue: 0,0:44:08.30,0:44:11.44,English,,0,0,0,,So the other place that you'll find
Dialogue: 0,0:44:12.50,0:44:16.82,English,,0,0,0,,Unsigned arithmetic unsigned representation use voice first of all
Dialogue: 0,0:44:17.30,0:44:19.06,English,,0,0,0,,When you're doing modular arithmetic
Dialogue: 0,0:44:19.06,0:44:24.46,English,,0,0,0,, Which is for example the way most encryption algorithms work
Dialogue: 0,0:44:25.24,0:44:28.56,English,,0,0,0,, Or when you're using the bits not to represent numbers
Dialogue: 0,0:44:28.56,0:44:32.20,English,,0,0,0,,But to represent sets the way I described it before
Dialogue: 0,0:44:32.66,0:44:39.36,English,,0,0,0,,Then you don't want it it's easiest to just think of that as unsigned numbers
Dialogue: 0,0:44:44.66,0:44:48.16,English,,0,0,0,, Okay so the final thing to talk about today is
Dialogue: 0,0:44:48.72,0:44:52.86,English,,0,0,0,,Some of the low-level representations of numbers within memory
Dialogue: 0,0:44:53.94,0:45:00.12,English,,0,0,0,,And the main point is when you are running a program on a computer
Dialogue: 0,0:45:02.38,0:45:09.38,English,,0,0,0,,From the programming perspective either, even not just as a C programmer
Dialogue: 0,0:45:09.96,0:45:13.20,English,,0,0,0,, In your mind the memory is just this big array of bytes
Dialogue: 0,0:45:13.82,0:45:17.34,English,,0,0,0,,That's numbered from 0 up to some maximum number
Dialogue: 0,0:45:17.80,0:45:22.54,English,,0,0,0,,So for example in the machines we're using the 64-bit machines
Dialogue: 0,0:45:24.12,0:45:27.68,English,,0,0,0,,I'll an address is represented in 64 bits
Dialogue: 0,0:45:29.18,0:45:31.28,English,,0,0,0,,But in fact the maximum address
Dialogue: 0,0:45:31.76,0:45:37.10,English,,0,0,0,,You're allowed to use in current machines is a 47 bits
Dialogue: 0,0:45:37.94,0:45:42.48,English,,0,0,0,, And 2^47 is still a pretty big number
Dialogue: 0,0:45:42.48,0:45:48.36,English,,0,0,0,,So that's more memory than anyone's able to buy right now anyhow
Dialogue: 0,0:45:48.38,0:45:50.26,English,,0,0,0,,And so it's a reasonable restriction
Dialogue: 0,0:45:50.26,0:45:57.76,English,,0,0,0,,But the point is that logically your program thinks that it has a of that many bytes
Dialogue: 0,0:45:58.18,0:46:02.54,English,,0,0,0,,Let's try and figure out how big 2^47 is. Anyone know it off the top of their head
Dialogue: 0,0:46:07.24,0:46:13.56,English,,0,0,0,,So there's a trick if you want to get an approximate idea
Dialogue: 0,0:46:14.70,0:46:25.66,English,,0,0,0,,Which is to say that 2^10 which is 1024 is approximately equal to 10^3
Dialogue: 0,0:46:28.20,0:46:30.16,English,,0,0,0,,You say oh well that's really helpful
Dialogue: 0,0:46:30.32,0:46:40.14,English,,0,0,0,,What it means is that 10 bits worth of number is about the same as three decimal digits all right
Dialogue: 0,0:46:40.64,0:46:53.94,English,,0,0,0,,So for example 2^20 is around 10^6
Dialogue: 0,0:46:55.16,0:46:59.24,English,,0,0,0,,2^30 it's around 10^9
Dialogue: 0,0:47:00.92,0:47:05.18,English,,0,0,0,,2^40 it's around 10^12
Dialogue: 0,0:47:07.06,0:47:09.60,English,,0,0,0,,And so that would tell you that
Dialogue: 0,0:47:10.46,0:47:22.56,English,,0,0,0,,2^47 is around 128*10^12. Which is 128 terabytes right  tera 10^12
Dialogue: 0,0:47:23.28,0:47:30.56,English,,0,0,0,,So if you just want to say you know get a quick figure 4 and of course these are approximations
Dialogue: 0,0:47:31.02,0:47:33.28,English,,0,0,0,, But if you just want to get a quick handle on
Dialogue: 0,0:47:33.44,0:47:38.78,English,,0,0,0,,How big a number you know what's range of values can I represent with so many bits of it
Dialogue: 0,0:47:38.96,0:47:41.32,English,,0,0,0,,This is a really easy trick to do that
Dialogue: 0,0:47:42.40,0:47:48.42,English,,0,0,0,,So the point is a 128 terabytes is a lot
Dialogue: 0,0:47:50.42,0:47:54.72,English,,0,0,0,,You can buy disk drives a couple of disk drives will do that for you
Dialogue: 0,0:47:54.72,0:48:00.28,English,,0,0,0,,But you couldn't buy enough DRAM on a normal budget to get that kind of memory
Dialogue: 0,0:48:00.78,0:48:06.06,English,,0,0,0,, So that's the the current range of values but logically when you run a program
Dialogue: 0,0:48:06.58,0:48:09.62,English,,0,0,0,, It thinks that it has that possible range
Dialogue: 0,0:48:09.62,0:48:11.52,English,,0,0,0,,Now it doesn't really
Dialogue: 0,0:48:11.68,0:48:18.96,English,,0,0,0,, And in fact what happens is that the operating system only allows certain regions within that memory to be referenced
Dialogue: 0,0:48:19.38,0:48:26.28,English,,0,0,0,,And other regions if you try to access them it will create a it will signal an error what they call a segmentation fault
Dialogue: 0,0:48:27.16,0:48:30.32,English,,0,0,0,,But logically at least it's as if you have this big array of bytes
Dialogue: 0,0:48:30.82,0:48:33.96,English,,0,0,0,,Now in reality and we'll go into this when we talk about
Dialogue: 0,0:48:33.96,0:48:37.74,English,,0,0,0,, How the memory system is works in virtual memory
Dialogue: 0,0:48:41.40,0:48:48.50,English,,0,0,0,, There's this very complex combination of hardware and software begins the program this image of a very large
Dialogue: 0,0:48:48.82,0:48:52.48,English,,0,0,0,,What you call flat space just a big array of bytes
Dialogue: 0,0:48:52.80,0:48:57.86,English,,0,0,0,,When in reality it's shuffling between different regions of your memory
Dialogue: 0,0:48:57.86,0:49:05.84,English,,0,0,0,,And even between your memory and your disk drive on your computer  to make it implement this particular
Dialogue: 0,0:49:08.98,0:49:10.83,English,,0,0,0,,Idea that you have this big array of bytes
Dialogue: 0,0:49:11.40,0:49:16.84,English,,0,0,0,,And that's all handled as I said by the operating system by the computer hardware
Dialogue: 0,0:49:17.12,0:49:22.12,English,,0,0,0,,And it's largely invisible even to the machine level programmer even people writing assembly code
Dialogue: 0,0:49:29.40,0:49:34.18,English,,0,0,0,,You'll often hear the term word size and it can get very confusing confusing nowadays
Dialogue: 0,0:49:34.18,0:49:38.40,English,,0,0,0,,Because there's no really fixed idea of what a word size is
Dialogue: 0,0:49:38.92,0:49:42.70,English,,0,0,0,,But roughly speaking the word size should be
Dialogue: 0,0:49:42.80,0:49:54.70,English,,0,0,0,, Whatever the largest number is that or  the range that sort of signifies how big a pointer is in this language
Dialogue: 0,0:49:55.12,0:50:00.36,English,,0,0,0,,Or hardware wise the largest sort of chunk of hardware for which
Dialogue: 0,0:50:00.36,0:50:05.10,English,,0,0,0,,There's standard support for storing it for arithmetic operations and so forth
Dialogue: 0,0:50:05.66,0:50:08.24,English,,0,0,0,,So when we say it's a 64-bit machine
Dialogue: 0,0:50:08.68,0:50:17.80,English,,0,0,0,, What we mean is that it it regular and routinely manipulate 64-bit values and arithmetic operations
Dialogue: 0,0:50:18.04,0:50:24.27,English,,0,0,0,, And also it has a pointers or the values of of addresses are 64-bit
Dialogue: 0,0:50:24.68,0:50:32.16,English,,0,0,0,,Even if for right now only 47 of those bits are usable it's still considered a 64-bit machine
Dialogue: 0,0:50:33.20,0:50:42.78,English,,0,0,0,, One thing that strange is in one of the features of of machines such as we have
Dialogue: 0,0:50:48.24,0:50:54.06,English,,0,0,0,,It is that if I compile a program using GCC is the standard compiler
Dialogue: 0,0:50:54.52,0:51:03.80,English,,0,0,0,, I can specify either I want it to be 64 bit code or 32 bit code as a flag
Dialogue: 0,0:51:07.22,0:51:11.66,English,,0,0,0,,And it will actually generate two different kinds of object code as a result
Dialogue: 0,0:51:12.18,0:51:15.14,English,,0,0,0,, And we'll talk in about these later
Dialogue: 0,0:51:15.46,0:51:22.76,English,,0,0,0,,But for right now the point is the hardware itself doesn't necessarily define what the word size is
Dialogue: 0,0:51:23.70,0:51:27.58,English,,0,0,0,,It's a combination of the hardware and the compiler  that determines
Dialogue: 0,0:51:27.58,0:51:31.08,English,,0,0,0,,What is the word size being used in this particular program
Dialogue: 0,0:51:31.62,0:51:36.02,English,,0,0,0,, And that code can be run on the point is a 64 bit machine
Dialogue: 0,0:51:36.02,0:51:39.04,English,,0,0,0,, Such as we have and most machines are nowadays
Dialogue: 0,0:51:39.28,0:51:46.54,English,,0,0,0,, Can insert of a backward compatibility a style also executes 32-bit code
Dialogue: 0,0:51:51.00,0:51:55.05,English,,0,0,0,,And as we also saw one of the other features is
Dialogue: 0,0:51:55.05,0:51:58.22,English,,0,0,0,,Even though it's a 64 bit word size the data type int
Dialogue: 0,0:51:59.22,0:52:03.42,English,,0,0,0,,Without any other qualifiers to it is just 32 bit
Dialogue: 0,0:52:03.56,0:52:07.24,English,,0,0,0,,So the sort of this mixture of how big things are
Dialogue: 0,0:52:07.24,0:52:09.76,English,,0,0,0,,So when people just say word or word size
Dialogue: 0,0:52:10.62,0:52:15.04,English,,0,0,0,,And let's say give a precise definition that's not a very meaningful term
Dialogue: 0,0:52:15.44,0:52:18.56,English,,0,0,0,,And we'll sort of throw it around when we mean sort of a generic
Dialogue: 0,0:52:18.96,0:52:23.50,English,,0,0,0,,Chunk of bits without trying to assume that it has a particular number of bits to it
Dialogue: 0,0:52:35.70,0:52:39.84,English,,0,0,0,,Yes so one of the things is if we ever get to 64-bit words
Dialogue: 0,0:52:41.10,0:52:48.04,English,,0,0,0,,It will be 16 petabytes 18 petabytes depending on how you define
Dialogue: 0,0:52:48.04,0:52:54.86,English,,0,0,0,,When you those numbers get big but the error due to this approximation gets more significant
Dialogue: 0,0:52:55.70,0:52:59.04,English,,0,0,0,,But something times 10^15 bytes
Dialogue: 0,0:52:59.16,0:53:04.64,English,,0,0,0,,But right now we can only get to 128*10^12
Dialogue: 0,0:53:12.12,0:53:17.08,English,,0,0,0,,So anyways the idea that that the memory itself is a series of bytes
Dialogue: 0,0:53:17.68,0:53:23.16,English,,0,0,0,,But we can group those into blocks of words of different word sizes
Dialogue: 0,0:53:23.56,0:53:34.82,English,,0,0,0,,And the way we do that is usually by assuming that the address of the word is the lowest value address in it
Dialogue: 0,0:53:35.16,0:53:38.18,English,,0,0,0,,And we also will generally try to align these
Dialogue: 0,0:53:38.72,0:53:46.88,English,,0,0,0,,So that for example a 32-bit word would be a line
Dialogue: 0,0:53:46.88,0:54:01.92,English,,0,0,0,,So its first byte its lowest byte has all zeros in the fruit stuff in the first 5 bit positions right
Dialogue: 0,0:54:02.44,0:54:05.62,English,,0,0,0,,No 32 4,I'm sorry the low is 2 bytes
Dialogue: 0,0:54:06.70,0:54:15.52,English,,0,0,0,,Right so as this example shows their address is 0,4,8  and 12
Dialogue: 0,0:54:15.52,0:54:18.20,English,,0,0,0,, They should have really written this in hex and set at C
Dialogue: 0,0:54:19.78,0:54:22.04,English,,0,0,0,,I guess these are all in decimal anyhow
Dialogue: 0,0:54:22.94,0:54:26.64,English,,0,0,0,,So yeah these are decimal numbers so 0,4,8,12
Dialogue: 0,0:54:27.00,0:54:31.30,English,,0,0,0,,So you see these are on multiples of 4 of bit boundaries
Dialogue: 0,0:54:31.94,0:54:35.48,English,,0,0,0,, And same way the 64-bit words are on multiples of 8
Dialogue: 0,0:54:35.98,0:54:42.48,English,,0,0,0,,And those are known as aligned words and will generally will see that the compiler works pretty hard to keep things aligned
Dialogue: 0,0:54:42.92,0:54:45.22,English,,0,0,0,,Because the hardware runs more efficiently that way
Dialogue: 0,0:54:45.90,0:54:50.14,English,,0,0,0,,But the main point is that we can just take as many bytes
Dialogue: 0,0:54:50.14,0:54:54.86,English,,0,0,0,,As we want and collect them together and call it a word for whatever word size we need
Dialogue: 0,0:54:56.44,0:55:00.22,English,,0,0,0,,And as we think we saw a variant of this table before
Dialogue: 0,0:55:00.24,0:55:07.16,English,,0,0,0,,But this is machines we'll be working on that  the standard int is still only 32 bits
Dialogue: 0,0:55:07.62,0:55:11.22,English,,0,0,0,, But if we qualify something as being wrong
Dialogue: 0,0:55:11.70,0:55:15.03,English,,0,0,0,,Then it will be 64 bits and will tend to do that
Dialogue: 0,0:55:15.72,0:55:19.22,English,,0,0,0,,There's two different floating-point representations that we'll talk about
Dialogue: 0,0:55:19.62,0:55:28.12,English,,0,0,0,,And then the main feature of a 64 bit machine  is it has an 8 byte or 64 bit pointer as compared to 32
Dialogue: 0,0:55:30.38,0:55:35.24,English,,0,0,0,,Now there's one other kind of detail that says ok
Dialogue: 0,0:55:35.24,0:55:37.90,English,,0,0,0,,So if a word has multiple bytes in it
Dialogue: 0,0:55:38.40,0:55:41.28,English,,0,0,0,,What order should those bytes be should it be the
Dialogue: 0,0:55:43.14,0:55:45.72,English,,0,0,0,,And there's two basic ways this could go one
Dialogue: 0,0:55:46.04,0:55:51.40,English,,0,0,0,,One is that you put the bytes in what's known as little endian order meaning that
Dialogue: 0,0:55:51.40,0:55:54.82,English,,0,0,0,,The first byte and the word is the least significant byte
Dialogue: 0,0:55:54.82,0:56:00.18,English,,0,0,0,,Then the next and the final byte in the word is the most significant
Dialogue: 0,0:56:00.64,0:56:03.84,English,,0,0,0,,Or you can flip that around and
Dialogue: 0,0:56:03.84,0:56:11.54,English,,0,0,0,,Those are called little-endian and big-endian is the sort of terms for that
Dialogue: 0,0:56:11.54,0:56:19.40,English,,0,0,0,,Which comes from English book called Gulliver's Travels
Dialogue: 0,0:56:19.40,0:56:21.94,English,,0,0,0,,Which didn't anticipate computers at all
Dialogue: 0,0:56:22.32,0:56:25.44,English,,0,0,0,,But it's an interesting story of how that comes about
Dialogue: 0,0:56:26.02,0:56:31.18,English,,0,0,0,,So in out there in the world you'll find both types of machines big-endian and little-endian machines
Dialogue: 0,0:56:31.80,0:56:36.40,English,,0,0,0,,It turns out that increasingly it's getting hard to find big-Endian machines
Dialogue: 0,0:56:36.96,0:56:40.52,English,,0,0,0,, So little-endian all of x86 is little-endian
Dialogue: 0,0:56:41.70,0:56:44.74,English,,0,0,0,, And it turns out ARM processors like
Dialogue: 0,0:56:44.74,0:56:50.14,English,,0,0,0,,What you have in almost every cell phone here is an ARM processor
Dialogue: 0,0:56:51.32,0:56:56.92,English,,0,0,0,,And the hardware those can actually be configured to run either way big-endian or little-endian
Dialogue: 0,0:56:57.50,0:57:07.48,English,,0,0,0,,But when you're running it on any of the standard operating systems that run on ARM processors then it's running little-endian
Dialogue: 0,0:57:07.50,0:57:14.80,English,,0,0,0,,So there used to be a brand called Sun Microsystems and they were fairly common on campus
Dialogue: 0,0:57:15.56,0:57:21.26,English,,0,0,0,,And then back in the Macintosh before they were x86 processors
Dialogue: 0,0:57:21.76,0:57:23.92,English,,0,0,0,, They ran one called the PowerPC
Dialogue: 0,0:57:25.42,0:57:27.36,English,,0,0,0,, And that was a big-endian machine
Dialogue: 0,0:57:27.36,0:57:30.15,English,,0,0,0,, But those are long in the distant past
Dialogue: 0,0:57:30.80,0:57:33.72,English,,0,0,0,,The internet's about the only place out there
Dialogue: 0,0:57:33.90,0:57:40.10,English,,0,0,0,, When you send packets over the internet and you want to send it of 32-bit words
Dialogue: 0,0:57:40.30,0:57:42.90,English,,0,0,0,, They're actually sent in big-endian order and so
Dialogue: 0,0:57:43.14,0:57:46.98,English,,0,0,0,,At the network interface you have to translate between those two
Dialogue: 0,0:57:48.40,0:57:51.60,English,,0,0,0,,So again just to illustrate what I mean by this
Dialogue: 0,0:57:51.96,0:57:57.64,English,,0,0,0,, is think of a byte value 4 byte value like this
Dialogue: 0,0:57:58.00,0:58:03.32,English,,0,0,0,,And remember that the way we write numbers is we put the most significant to the left
Dialogue: 0,0:58:03.78,0:58:05.84,English,,0,0,0,,And the least significant to the right
Dialogue: 0,0:58:09.60,0:58:17.74,English,,0,0,0,, And so now with a big-endian instead of the intuitive one from that perspective in that the bikes
Dialogue: 0,0:58:17.74,0:58:23.10,English,,0,0,0,,If you write the words in memory from the smallest address up to the highest
Dialogue: 0,0:58:23.68,0:58:26.44,English,,0,0,0,,The big-endian will sort of map to what you see
Dialogue: 0,0:58:26.92,0:58:30.88,English,,0,0,0,, Whereas a little-endian will look confusing
Dialogue: 0,0:58:31.16,0:58:34.56,English,,0,0,0,, that you say 01,23,45,67
Dialogue: 0,0:58:34.56,0:58:39.06,English,,0,0,0,,Because 67 is actually the least significant byte here
Dialogue: 0,0:58:39.06,0:58:41.68,English,,0,0,0,, And so that comes first in little-endian order
Dialogue: 0,0:58:43.20,0:58:49.68,English,,0,0,0,,And so the it used to be people would get in passionate arguments about this
Dialogue: 0,0:58:50.16,0:58:52.50,English,,0,0,0,,That's sort of in the distant past
Dialogue: 0,0:58:53.04,0:58:55.36,English,,0,0,0,,But and people saying you know
Dialogue: 0,0:58:57.62,0:59:04.14,English,,0,0,0,,And the main feature in some sort of argument of big-endian is's this feature here that
Dialogue: 0,0:59:04.46,0:59:06.94,English,,0,0,0,,When you look at it it's easier to write down
Dialogue: 0,0:59:07.54,0:59:09.38,English,,0,0,0,,But computers don't really care
Dialogue: 0,0:59:09.50,0:59:13.00,English,,0,0,0,,They're happy either way and so they just want one convention or another
Dialogue: 0,0:59:13.30,0:59:20.64,English,,0,0,0,,And like I said some hardware's can actually be a by a sort of flag to flip it from  being big-endian to little-endian
Dialogue: 0,0:59:21.12,0:59:26.62,English,,0,0,0,,But the reality is most of machines  one counter you'll encounter a little-endian machine days
Dialogue: 0,0:59:27.68,0:59:29.42,English,,0,0,0,,But just to give you an example
Dialogue: 0,0:59:29.94,0:59:35.68,English,,0,0,0,,Here some results that I got from actual machines there used to be some machines around
Dialogue: 0,0:59:36.58,0:59:38.88,English,,0,0,0,,So back in the old days I could run this
Dialogue: 0,0:59:38.88,0:59:42.66,English,,0,0,0,,I don't even know where to get a big-endian machine anymore
Dialogue: 0,0:59:43.08,0:59:46.28,English,,0,0,0,,So these are sort of legacy results
Dialogue: 0,0:59:47.92,0:59:52.44,English,,0,0,0,,But you'll see that the main feature is between a little-endian and a big-endian machine
Dialogue: 0,0:59:52.74,0:59:56.76,English,,0,0,0,,When you have a integer the bytes get flipped around
Dialogue: 0,0:59:57.68,1:00:04.74,English,,0,0,0,, So that the least significant byte comes first in a little-endian machine  and last in a big-endian machine
Dialogue: 0,1:00:05.74,1:00:08.72,English,,0,0,0,, And that's true with negative numbers as well
Dialogue: 0,1:00:09.28,1:00:14.28,English,,0,0,0,, That you'll get the the sign bits first in a big-endian machine
Dialogue: 0,1:00:15.70,1:00:25.70,English,,0,0,0,,Along you'll see that the only difference between a 32-bit machine a 64-bit machine
Dialogue: 0,1:00:25.70,1:00:30.70,English,,0,0,0,, is you have more zeros or more ones depending whether it's a positive or negative number
Dialogue: 0,1:00:31.56,1:00:37.44,English,,0,0,0,,And again the a Sun and if I had access to a 64 bit machine
Dialogue: 0,1:00:37.66,1:00:41.24,English,,0,0,0,,Sun is now manufactured by a company called Oracle
Dialogue: 0,1:00:41.24,1:00:45.72,English,,0,0,0,, So in principle I could go get one of these machines and run this experiment
Dialogue: 0,1:00:46.00,1:00:48.96,English,,0,0,0,, But it's really not a very interesting experiment so I won't bother
Dialogue: 0,1:00:51.68,1:00:59.00,English,,0,0,0,,So in principle I could try it on a 64-bit Oracle machine and show you something different
Dialogue: 0,1:01:02.72,1:01:08.66,English,,0,0,0,, So one thing that it's kind of a useful tool the book goes through some examples of this
Dialogue: 0,1:01:09.24,1:01:17.24,English,,0,0,0,,is a little program that will take a series of bytes starting at some position start
Dialogue: 0,1:01:17.86,1:01:21.16,English,,0,0,0,,And do it for however many bytes you request
Dialogue: 0,1:01:21.54,1:01:24.90,English,,0,0,0,, And just print out in hex format
Dialogue: 0,1:01:25.28,1:01:30.70,English,,0,0,0,,The two hex digits that represent that byte valve
Dialogue: 0,1:01:31.94,1:01:41.02,English,,0,0,0,,And here this term pointer I'm using an unsigned char  as a pointer type a sort of generic pointer type
Dialogue: 0,1:01:47.58,1:01:53.96,English,,0,0,0,,And so again if I run this on a x86 machine
Dialogue: 0,1:01:56.28,1:01:59.12,English,,0,0,0,, I'll oh and I'm also by the way printing out the actual address
Dialogue: 0,1:01:59.26,1:02:03.30,English,,0,0,0,,This character is stored it to
Dialogue: 0,1:02:03.74,1:02:09.42,English,,0,0,0,,And so you'll see that there is these addresses with a lot of 7 Fs
Dialogue: 0,1:02:10.22,1:02:15.02,English,,0,0,0,,What that means is it's in the upper end of this 47 bit address space
Dialogue: 0,1:02:15.02,1:02:16.76,English,,0,0,0,, If you work it through
Dialogue: 0,1:02:17.46,1:02:21.48,English,,0,0,0,,There's seven is three ones and then there's
Dialogue: 0,1:02:22.58,1:02:26.36,English,,0,0,0,, Enough hex digits here to correspond to
Dialogue: 0,1:02:27.12,1:02:29.72,English,,0,0,0,,So there's 11 hex digits beyond the seven
Dialogue: 0,1:02:31.66,1:02:37.52,English,,0,0,0,,And you'll see that these addresses are at successive bytes bc,bd,be,bf
Dialogue: 0,1:02:38.24,1:02:42.98,English,,0,0,0,,And the values are 0x6d3b0000 this is the least significant byte
Dialogue: 0,1:02:43.34,1:02:45.04,English,,0,0,0,,And these are the successive bytes
Dialogue: 0,1:02:48.24,1:02:56.54,English,,0,0,0,,And similarly I can  use this to examine pointers of various sorts
Dialogue: 0,1:02:56.54,1:03:01.60,English,,0,0,0,,And I can examine different values and just get their low-level byte representations
Dialogue: 0,1:03:02.18,1:03:05.76,English,,0,0,0,,And so I did this back when I could get to a Sun machine
Dialogue: 0,1:03:05.78,1:03:07.92,English,,0,0,0,,It had one way of representing a pointer
Dialogue: 0,1:03:08.30,1:03:10.66,English,,0,0,0,,And the main point is even across machines
Dialogue: 0,1:03:10.66,1:03:14.02,English,,0,0,0,,Whether it's a byte ordering or whatever
Dialogue: 0,1:03:14.44,1:03:21.82,English,,0,0,0,, You'll get different values for pointers,there's no guarantee  that when you load imputed a min to one machine and run it
Dialogue: 0,1:03:22.04,1:03:28.06,English,,0,0,0,,That it will use the same addresses as that same programming running on a different machine
Dialogue: 0,1:03:28.06,1:03:32.38,English,,0,0,0,,Even if actually they're identical hardware and operating system there can be variation
Dialogue: 0,1:03:33.44,1:03:39.22,English,,0,0,0,, Because pointers aren't you you can't directly copy a pointer from one machine to another
Dialogue: 0,1:03:41.24,1:03:51.32,English,,0,0,0,,On one thing about also is regardless of byte ordering  the ordering of of characters is the same 
Dialogue: 0,1:03:51.32,1:03:56.54,English,,0,0,0,,And so a string in C is always represented by a series of bytes
Dialogue: 0,1:03:57.02,1:04:01.20,English,,0,0,0,,Where the final byte is 0 note called null terminator
Dialogue: 0,1:04:01.50,1:04:08.06,English,,0,0,0,,And the individual bytes correspond to the character codes for that number
Dialogue: 0,1:04:08.36,1:04:12.92,English,,0,0,0,,And these character codes are just sometimes called ASCII format
Dialogue: 0,1:04:13.68,1:04:15.78,English,,0,0,0,,Which is a little bit old-fashioned by the way
Dialogue: 0,1:04:16.08,1:04:23.98,English,,0,0,0,, There's more modern character codes too that can represent non English alphabets
Dialogue: 0,1:04:24.44,1:04:32.14,English,,0,0,0,,But the C standard is still back in the days of only supporting the the ASCII format
Dialogue: 0,1:04:32.14,1:04:33.14,English,,0,0,0,,Question
Dialogue: 0,1:04:33.14,1:04:50.10,English,,0,0,0,, [student speaking]
Dialogue: 0,1:04:50.18,1:05:01.58,English,,0,0,0,,Yes!So this should have been...well no this is good so I'm casting
Dialogue: 0,1:05:01.88,1:05:05.00,English,,0,0,0,,I want to show the 4 bytes size event
Dialogue: 0,1:05:05.24,1:05:07.00,English,,0,0,0,,Because this is an int I'm representing
Dialogue: 0,1:05:07.80,1:05:11.44,English,,0,0,0,, The pointer let's see the code where it's printing the pointer
Dialogue: 0,1:05:12.20,1:05:19.68,English,,0,0,0,,All this notation %p is the directive to say print out a pointer proposed right
Dialogue: 0,1:05:20.18,1:05:25.74,English,,0,0,0,,And %x is the directive to print out a hex representation
Dialogue: 0,1:05:26.68,1:05:31.54,English,,0,0,0,, So it's printing out both the address the starting position of that particular byte
Dialogue: 0,1:05:31.90,1:05:34.66,English,,0,0,0,, And the value of that byte as two different things
Dialogue: 0,1:05:35.56,1:05:36.90,English,,0,0,0,,Does that answer your question?
Dialogue: 0,1:05:37.04,1:05:51.98,English,,0,0,0,,[student speaking]
Dialogue: 0,1:05:52.10,1:06:00.42,English,,0,0,0,,But remember show bytes is being given a pointer and a length
Dialogue: 0,1:06:01.50,1:06:09.02,English,,0,0,0,,And so what this is and what it's saying is starting at that address print out the next series of bytes for me
Dialogue: 0,1:06:09.02,1:06:11.22,English,,0,0,0,,How many bytes I asked for
Dialogue: 0,1:06:11.62,1:06:15.68,English,,0,0,0,, And in this case I'm creating a pointer to this integer
Dialogue: 0,1:06:15.90,1:06:22.26,English,,0,0,0,, But I want to show the the bytes in that integer the four bytes that make up that integer
Dialogue: 0,1:06:22.70,1:06:26.90,English,,0,0,0,, And that's why I'm giving it the number four here instead of eight is it
Dialogue: 0,1:06:26.90,1:06:32.84,English,,0,0,0,,[student speaking]
Dialogue: 0,1:06:32.84,1:06:34.62,English,,0,0,0,,Yes it will be
Dialogue: 0,1:06:34.62,1:06:37.46,English,,0,0,0,, And that's fine because in this code
Dialogue: 0,1:06:37.84,1:06:43.78,English,,0,0,0,, It's I'm using the %p directive to designate how to print out the pointer
Dialogue: 0,1:06:44.34,1:06:49.89,English,,0,0,0,,And that will print it as many bytes as it takes for that particular machine that it's running on
Dialogue: 0,1:06:50.74,1:06:53.64,English,,0,0,0,,So %p is actually a very handy directive
Dialogue: 0,1:06:53.64,1:06:57.50,English,,0,0,0,, If you have to print it addresses like for debugging purposes or something
Dialogue: 0,1:06:57.50,1:07:01.32,English,,0,0,0,, Because it will automatically adapt to whatever machine it's running on
Dialogue: 0,1:07:02.72,1:07:03.24,English,,0,0,0,,Question
Dialogue: 0,1:07:03.40,1:07:07.32,English,,0,0,0,,[student speaking]
Dialogue: 0,1:07:07.78,1:07:11.15,English,,0,0,0,,Well I've defined it to be an unsigned care here
Dialogue: 0,1:07:11.66,1:07:18.00,English,,0,0,0,,So type death is a way to introduce a name for some of datatype right
Dialogue: 0,1:07:18.36,1:07:25.56,English,,0,0,0,,And so I've just declared a pointer quote pointer to refer to an unsigned care
Dialogue: 0,1:07:26.36,1:07:34.34,English,,0,0,0,,If you did a void * it would not be happy with this reference here right
Dialogue: 0,1:07:34.40,1:07:41.52,English,,0,0,0,,You can't reference a void * is just a way to pass around a generic pointer
Dialogue: 0,1:07:41.52,1:07:43.56,English,,0,0,0,, But you can't actually reference that element
Dialogue: 0,1:07:44.06,1:07:49.70,English,,0,0,0,, So what I'm basically doing is saying this reference is treat it like an array
Dialogue: 0,1:07:50.38,1:07:56.54,English,,0,0,0,, Treat you treat my series of bytes is an array and print out each of the bytes in that array
Dialogue: 0,1:08:01.26,1:08:07.16,English,,0,0,0,,And so here where I'm a is a number
Dialogue: 0,1:08:07.42,1:08:11.18,English,,0,0,0,, And I'm taking the address of that integer
Dialogue: 0,1:08:11.58,1:08:14.90,English,,0,0,0,,And casting it to be an unsigned char *
Dialogue: 0,1:08:16.00,1:08:20.68,English,,0,0,0,,So sort of a generic slightly generic pointer but not quite as generic as void *
Dialogue: 0,1:08:21.58,1:08:26.50,English,,0,0,0,,And then printing it out.It's good question by the way
Dialogue: 0,1:08:31.00,1:08:34.58,English,,0,0,0,,Okay so the point being that strings are just strings
Dialogue: 0,1:08:34.58,1:08:37.58,English,,0,0,0,,So that's the same from one machine to the next
Dialogue: 0,1:08:39.20,1:08:42.26,English,,0,0,0,, Okay what soonish up today with some puzzles
Dialogue: 0,1:08:42.26,1:08:46.48,English,,0,0,0,,And these have this annoying way of showing up on exams
Dialogue: 0,1:08:46.84,1:08:50.66,English,,0,0,0,,So it's worth being able to do these kind of things
Dialogue: 0,1:08:52.76,1:08:57.12,English,,0,0,0,,And you'll also notice I cleverly did not include the answers in the slides
Dialogue: 0,1:09:00.84,1:09:04.36,English,,0,0,0,,So you can't just peek ahead and figure out what the answers are
Dialogue: 0,1:09:04.36,1:09:08.42,English,,0,0,0,, So let's just go through them but I actually worked them out to make sure I have the answers
Dialogue: 0,1:09:09.04,1:09:16.62,English,,0,0,0,, So if x and basically these are sort of statements that you want to say these are either always true
Dialogue: 0,1:09:17.02,1:09:19.82,English,,0,0,0,,And maybe there's some logic behind why it's always true
Dialogue: 0,1:09:20.22,1:09:25.40,English,,0,0,0,,Or it's possibly false and you won't have to give some example that would make that false
Dialogue: 0,1:09:26.26,1:09:31.92,English,,0,0,0,,So let's go through these as many as we have time for  and see where we get to
Dialogue: 0,1:09:31.92,1:09:35.56,English,,0,0,0,,So if I take x and I double it multiply it by 2
Dialogue: 0,1:09:35.98,1:09:41.43,English,,0,0,0,, if x who are negative and my guaranteed that 2x will be negative
Dialogue: 0,1:09:42.12,1:09:43.98,English,,0,0,0,,No so
Dialogue: 0,1:09:44.68,1:09:49.82,English,,0,0,0,,By the way one general way to find counter examples is to try team in
Dialogue: 0,1:09:50.46,1:09:51.74,English,,0,0,0,,It's a really good one
Dialogue: 0,1:09:52.40,1:09:57.44,English,,0,0,0,,And that works here right if I take team n which is one and a bunch of zeros I double it
Dialogue: 0,1:09:57.96,1:10:02.90,English,,0,0,0,,It's like shifting it but left and it will become what 0 right
Dialogue: 0,1:10:05.12,1:10:09.58,English,,0,0,0,,And so again assume that x is at any negative number
Dialogue: 0,1:10:09.58,1:10:14.66,English,,0,0,0,, And ux is any two's complement number
Dialogue: 0,1:10:15.08,1:10:19.20,English,,0,0,0,,And ux is what happens if I cast it to be unsigned
Dialogue: 0,1:10:19.42,1:10:22.06,English,,0,0,0,,So as ux always you're greater than or equal to 0
Dialogue: 0,1:10:23.04,1:10:23.48,English,,0,0,0,,Yeah
Dialogue: 0,1:10:25.84,1:10:32.16,English,,0,0,0,,This is slightly more obscure if I take x and I mask off 7
Dialogue: 0,1:10:32.16,1:10:34.78,English,,0,0,0,,you remember is the bit pattern 111
Dialogue: 0,1:10:35.34,1:10:38.18,English,,0,0,0,,So if I mask off all but the lowest 3 bits
Dialogue: 0,1:10:40.10,1:10:41.96,English,,0,0,0,,And I find that those are all ones
Dialogue: 0,1:10:42.30,1:10:44.25,English,,0,0,0,,I'm already giving you the answer here
Dialogue: 0,1:10:44.25,1:10:47.08,English,,0,0,0,,And then I shift it left by 30 positions
Dialogue: 0,1:10:47.50,1:10:59.45,English,,0,0,0,,What can I say about the result
Dialogue: 0,1:10:59.84,1:11:06.00,English,,0,0,0,,So I know the x must finish with three ones right
Dialogue: 0,1:11:07.30,1:11:20.18,English,,0,0,0,, And I shift that by thirty
Dialogue: 0,1:11:20.18,1:11:25.24,English,,0,0,0,,And this these will be the only two bits that are left after the shifting
Dialogue: 0,1:11:25.76,1:11:29.32,English,,0,0,0,,And they will be in the most significant position
Dialogue: 0,1:11:29.32,1:11:33.02,English,,0,0,0,,So what can I say about that number is negative
Dialogue: 0,1:11:33.34,1:11:37.51,English,,0,0,0,,So this is a true statement rather obscure,but it is true
Dialogue: 0,1:11:38.18,1:11:40.96,English,,0,0,0,,Is UX greater than -1?
Dialogue: 0,1:11:45.64,1:11:50.66,English,,0,0,0,,It's almost true right
Dialogue: 0,1:11:50.78,1:11:58.14,English,,0,0,0,,The one counterexample would be what zero
Dialogue: 0,1:11:59.26,1:12:03.40,English,,0,0,0,,Well actually no you're right there's a lot of examples it's hardly ever true
Dialogue: 0,1:12:03.52,1:12:06.32,English,,0,0,0,,It's almost always false I was wrong
Dialogue: 0,1:12:06.98,1:12:13.04,English,,0,0,0,,The only thing that would make it true would be...it's never true
Dialogue: 0,1:12:13.20,1:12:15.78,English,,0,0,0,,[student laugh]
Dialogue: 0,1:12:15.78,1:12:16.88,English,,0,0,0,,Okay so it's never true
Dialogue: 0,1:12:18.40,1:12:23.40,English,,0,0,0,,Okay if x is greater than y is -x less than -y
Dialogue: 0,1:12:35.24,1:12:39.38,English,,0,0,0,,No so by the way one thing we didn't really cover is
Dialogue: 0,1:12:39.78,1:12:46.94,English,,0,0,0,,What is the negative of Tmin
Dialogue: 0,1:12:46.94,1:12:50.46,English,,0,0,0,,And to see that we can use our compliment  and income increment trick
Dialogue: 0,1:12:58.95,1:13:04.82,English,,0,0,0,,So when you compliment and increment G min you get Tmin
Dialogue: 0,1:13:05.22,1:13:08.90,English,,0,0,0,,And that's a why it's such a great counter example
Dialogue: 0,1:13:10.64,1:13:19.13,English,,0,0,0,, So in particular if y is tmin and x is something else
Dialogue: 0,1:13:19.92,1:13:24.22,English,,0,0,0,,Then that left-hand part will be true but the right-hand part will not be true
Dialogue: 0,1:13:27.02,1:13:34.54,English,,0,0,0,,Okay x*x greater than or equal to zero we've seen examples of that being false
Dialogue: 0,1:13:37.60,1:13:45.18,English,,0,0,0,,If x is...this is kind of silly. If x is greater than 0 and y is greater than 0. Is x+y > 0.No
Dialogue: 0,1:13:47.24,1:13:51.90,English,,0,0,0,,If x >= 0. Is -x<= 0
Dialogue: 0,1:13:54.28,1:13:57.48,English,,0,0,0,,Gotcha, you're right it's true right
Dialogue: 0,1:13:58.12,1:14:06.03,English,,0,0,0,, Because that...but let's take it counter part.If x <=0. Is -x >= 0
Dialogue: 0,1:14:06.90,1:14:14.82,English,,0,0,0,,Tmin right so right the point being that the largest any positive number can be represented as negative
Dialogue: 0,1:14:15.40,1:14:19.46,English,,0,0,0,,But there's one negative number that can't be represented as positive
Dialogue: 0,1:14:20.18,1:14:24.00,English,,0,0,0,,And so that asymmetry is why you get different answers to these
Dialogue: 0,1:14:25.44,1:14:31.76,English,,0,0,0,, If I take x and I look at -x and I shift them to the right by 31
Dialogue: 0,1:14:33.60,1:14:35.20,English,,0,0,0,,Am I going to get all ones
Dialogue: 0,1:14:36.44,1:14:48.08,English,,0,0,0,, This is a really weird statement
Dialogue: 0,1:14:48.90,1:14:51.02,English,,0,0,0,,So it actually kind of works right
Dialogue: 0,1:14:51.48,1:15:02.56,English,,0,0,0,,If I take all zeros
Dialogue: 0,1:15:03.00,1:15:11.66,English,,0,0,0,,And I subtract one I'll get -1
Dialogue: 0,1:15:11.66,1:15:18.68,English,,0,0,0,,And I all them, that works
Dialogue: 0,1:15:19.52,1:15:20.64,English,,0,0,0,,So what's wrong with this?
Dialogue: 0,1:15:25.24,1:15:25.80,English,,0,0,0,,what's that?
Dialogue: 0,1:15:27.62,1:15:32.82,English,,0,0,0,,Oh but if I shift this to the right 31 places it's going to shift arithmetic
Dialogue: 0,1:15:32.84,1:15:41.82,English,,0,0,0,,[student speaking]
Dialogue: 0,1:15:42.32,1:15:43.22,English,,0,0,0,,What's that?
Dialogue: 0,1:15:46.14,1:15:50.84,English,,0,0,0,,Oh I see, oh I'm sorry I already jumped ahead to a different puzzle
Dialogue: 0,1:15:52.94,1:15:59.01,English,,0,0,0,, x and  -x and I'm so you're right actually
Dialogue: 0,1:15:59.88,1:16:08.50,English,,0,0,0,,If the two numbers are 0 and I or those I get 0
Dialogue: 0,1:16:08.92,1:16:12.54,English,,0,0,0,, But you'll figure out you'll notice if it's anything non zero
Dialogue: 0,1:16:13.46,1:16:14.82,English,,0,0,0,,Actually this will be true
Dialogue: 0,1:16:16.12,1:16:18.04,English,,0,0,0,,And that's an interesting feature
Dialogue: 0,1:16:18.26,1:16:22.04,English,,0,0,0,,So there's a couple other puzzles and I'll let you solve those on your own
Dialogue: 0,1:16:22.08,1:16:25.22,English,,0,0,0,, We're all set for today
